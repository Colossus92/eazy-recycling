# ADR-0012: Exact Online Company Synchronization Strategy

## Status

Proposed

## Context

We need a robust bidirectional synchronization strategy between Eazy Recycling and Exact Online for company data. The primary flow is:

1. **Initial sync**: Import existing companies from Exact Online
2. **Ongoing outbound**: Propagate creates/updates from Eazy Recycling to Exact Online
3. **Ongoing inbound**: Handle changes made directly in Exact Online

### Current State

#### Database Schema

**`companies` table:**

| Column | Type | Constraint |
|--------|------|------------|
| `id` | UUID | PRIMARY KEY |
| `chamber_of_commerce_id` | text | UNIQUE (nullable) |
| `vihb_id` | text | UNIQUE (nullable) |
| `processor_id` | text | UNIQUE (nullable) |
| `name` | text | NOT NULL |
| `street_name`, `postal_code`, `city` | text | NOT NULL |

**`companies_sync` table:**

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | PRIMARY KEY |
| `company_id` | UUID | FK to companies |
| `external_id` | text | Exact Online Code (nullable) |
| `sync_status` | text | OK, FAILED |
| `synced_from_source_at` | timestamp | Last sync time |
| `last_timestamp` | bigint | Exact Sync API timestamp |

#### Exact Online Constraints

From the CRM/Accounts API:

- **ID** (Edm.Guid): Primary key, auto-generated by Exact, immutable after creation
- **Code** (Edm.String): Auto-generated sequential number, unique per division, immutable
- **ChamberOfCommerce** (Edm.String): KVK number, not enforced as unique by Exact
- **Name** (Edm.String): Company name, not unique

#### Domain Model (`Company.kt`)

- `companyId: CompanyId` (UUID)
- `chamberOfCommerceId: String?`
- `vihbNumber: VihbNumber?`
- `processorId: ProcessorPartyId?`

### Current Implementation Issues

1. **UUID propagation to Exact**: Currently sending our UUID as the Exact `ID` field. This works for creates but:
   - Exact's `ID` is immutable after creation
   - If we need to merge companies later, we cannot change the Exact ID
   - Creates a tight coupling between systems

2. **Matching strategy gaps**: Current matching uses:
   - Chamber of Commerce ID (KVK)
   - External ID (Exact Code) via sync table
   - **Missing**: No handling for companies without KVK that exist in both systems

3. **Unique constraint violations**: When syncing from Exact, if a company has a KVK that already exists in our database (but wasn't linked), the sync fails.

---

## Decision

### 1. Identity Strategy: Decouple UUIDs

**Principle**: Each system owns its own primary key. Link via the sync table.

| System | Primary Key | Stored In |
|--------|-------------|-----------|
| Eazy Recycling | `companies.id` (UUID) | `companies` table |
| Exact Online | `ID` (GUID) | `companies_sync.exact_guid` |
| Exact Online | `Code` | `companies_sync.external_id` |

**Changes required:**
- Add `exact_guid` column to `companies_sync` table
- Stop sending our UUID as Exact's `ID` - let Exact auto-generate
- Store both Exact's `ID` (GUID) and `Code` in sync table

### 2. Matching Strategy: Multi-Key Resolution

When syncing from Exact, resolve matches in this priority order:

```text
1. exact_guid     → Direct link (highest confidence)
2. external_id    → Exact Code link
3. chamber_of_commerce_id → Business key match (KVK)
4. postal_code + building_number + building_number_addition → Exact address match (requires manual review)
5. No match       → Create new company
```

**For outbound sync (Eazy → Exact):**

```text
1. Check companies_sync for existing exact_guid
   → If exists: UPDATE in Exact
   → If not: CREATE in Exact, store returned ID/Code
```

### 3. Conflict Resolution Strategy

#### Scenario A: KVK Collision on Inbound Sync

**Problem**: Exact has company with KVK "12345678", our DB already has a different company with same KVK.

**Solution**:

1. Detect collision before insert
2. Mark as `CONFLICT` status in sync table
3. Log for manual resolution
4. Do NOT auto-merge or overwrite

```kotlin
enum class SyncStatus {
    OK,
    FAILED,
    CONFLICT,      // New: requires manual resolution
    PENDING_REVIEW // New: fuzzy match needs confirmation
}
```

#### Scenario B: Duplicate Creation Race Condition

**Problem**: User creates company in Eazy, another user creates same company in Exact before sync completes.

**Solution**:

1. On outbound sync, first check if KVK exists in Exact
2. If found, link to existing Exact account instead of creating
3. Store the found Exact ID/Code in sync table

#### Scenario C: Conflicting Updates

**Problem**: Company updated in both systems between syncs.

**Solution**:

- **Last-write-wins** with audit trail
- Store `updated_at` from both systems
- Log conflicts for review
- Consider field-level merge for non-conflicting fields

### 4. Unique Constraint Handling

#### Database-Level Protection

Current unique constraints on `companies`:

- `chamber_of_commerce_id`
- `vihb_id`
- `processor_id`

**Recommendation**: Keep these constraints but handle violations gracefully:

```kotlin
fun processExactAccount(account: ExactSyncAccount): SyncResult {
    try {
        // Attempt upsert
        upsertCompany(account)
    } catch (e: DataIntegrityViolationException) {
        // Unique constraint violation
        return SyncResult.Conflict(
            field = detectConflictingField(e),
            existingCompanyId = findExistingByConstraint(account),
            exactAccountId = account.ID
        )
    }
}
```

#### Pre-Sync Validation

Before creating/updating, check for potential conflicts:

```kotlin
fun validateBeforeSync(account: ExactSyncAccount): ValidationResult {
    val conflicts = mutableListOf<ConflictInfo>()
    
    account.ChamberOfCommerce?.let { kvk ->
        companies.findByChamberOfCommerceId(kvk)?.let { existing ->
            if (!isLinkedToExactAccount(existing, account.ID)) {
                conflicts.add(ConflictInfo("chamber_of_commerce_id", kvk, existing.companyId))
            }
        }
    }
    
    return if (conflicts.isEmpty()) ValidationResult.Valid 
           else ValidationResult.HasConflicts(conflicts)
}
```

### 5. Sync Table Schema Enhancement

```sql
ALTER TABLE companies_sync ADD COLUMN exact_guid UUID;
ALTER TABLE companies_sync ADD COLUMN conflict_details JSONB;
ALTER TABLE companies_sync ADD COLUMN requires_manual_review BOOLEAN DEFAULT FALSE;

-- Add unique constraint on exact_guid
CREATE UNIQUE INDEX companies_sync_exact_guid_key 
    ON companies_sync (exact_guid) WHERE exact_guid IS NOT NULL;

-- Add unique constraint on external_id (Exact Code)
CREATE UNIQUE INDEX companies_sync_external_id_key 
    ON companies_sync (external_id) WHERE external_id IS NOT NULL;
```

### 6. Sync Flow Diagrams

#### Outbound Sync (Eazy → Exact)

```text
┌─────────────────────────────────────────────────────────────────┐
│                    CREATE COMPANY IN EAZY                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Has KVK number? │
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │ YES                         │ NO
              ▼                             ▼
    ┌─────────────────────┐      ┌─────────────────────┐
    │ Search Exact by KVK │      │ Create in Exact     │
    └──────────┬──────────┘      │ (let Exact gen ID)  │
               │                 └──────────┬──────────┘
    ┌──────────┴──────────┐                 │
    │ FOUND               │ NOT FOUND       │
    ▼                     ▼                 ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────┐
│ Link existing │  │ Create new    │  │ Store Exact   │
│ Exact account │  │ in Exact      │  │ ID + Code     │
└───────────────┘  └───────────────┘  └───────────────┘
```

#### Inbound Sync (Exact → Eazy)

```text
┌─────────────────────────────────────────────────────────────────┐
│              FETCH CHANGED ACCOUNTS FROM EXACT                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ For each account│
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────────────────┐
              │ Match by exact_guid?     │
              └────────────┬─────────────┘
                           │
         ┌─────────────────┼─────────────────┐
         │ YES             │ NO              │
         ▼                 ▼                 │
   ┌───────────┐    ┌──────────────┐         │
   │ UPDATE    │    │ Match by     │         │
   │ existing  │    │ external_id? │         │
   └───────────┘    └──────┬───────┘         │
                           │                 │
              ┌────────────┼────────────┐    │
              │ YES        │ NO         │    │
              ▼            ▼            │    │
        ┌───────────┐ ┌──────────────┐  │    │
        │ UPDATE    │ │ Match by KVK?│  │    │
        │ existing  │ └──────┬───────┘  │    │
        └───────────┘        │          │    │
                    ┌────────┼────────┐ │    │
                    │ YES    │ NO     │ │    │
                    ▼        ▼        │ │    │
              ┌───────────┐ ┌─────────────────┐
              │ CONFLICT! │ │ CREATE new      │
              │ Mark for  │ │ company + link  │
              │ review    │ └─────────────────┘
              └───────────┘
```

---

## Risks and Mitigations

### Risk 1: Data Loss from Overwrites

**Risk**: Inbound sync overwrites local changes.

**Mitigation**:

- Compare `updated_at` timestamps
- Log all overwrites with before/after values
- Consider field-level merge instead of full overwrite

### Risk 2: Orphaned Records

**Risk**: Company deleted in one system but not the other.

**Mitigation**:

- Soft-delete only (both systems)
- Track `deleted_in_source` flag in sync table
- Never hard-delete during sync

### Risk 3: KVK Data Quality

**Risk**: KVK numbers may be incorrect, duplicated, or missing in Exact.

**Mitigation**:

- KVK is optional for matching
- Validate KVK format before using as match key
- Flag suspicious matches for review

### Risk 4: Sync Failures Causing Inconsistency

**Risk**: Partial sync leaves systems out of sync.

**Mitigation**:

- Process each account in its own transaction
- Track individual record status
- Implement retry mechanism for failed records
- Provide admin UI to view/resolve sync issues

### Risk 5: Race Conditions

**Risk**: Concurrent modifications during sync window.

**Mitigation**:

- Use optimistic locking with timestamps
- Exact's Sync API provides monotonic timestamps
- Store and compare `last_timestamp` per record

---

## Implementation Phases

### Phase 1: Schema Updates

1. Add `exact_guid` column to `companies_sync`
2. Add `conflict_details` JSONB column
3. Add `requires_manual_review` flag
4. Add unique indexes

### Phase 2: Decouple UUID

1. Stop sending our UUID as Exact's ID
2. Store Exact's returned GUID in `exact_guid`
3. Update matching logic to use `exact_guid` first

### Phase 3: Conflict Detection

1. Implement pre-sync validation
2. Add `CONFLICT` and `PENDING_REVIEW` statuses
3. Create admin endpoint to list conflicts

### Phase 4: Conflict Resolution UI

1. Admin page showing sync conflicts
2. Manual merge/link functionality
3. Audit logging for resolutions

---

## Consequences

### Positive

- Decoupled identity allows future flexibility (merging, splitting companies)
- Explicit conflict handling prevents silent data corruption
- Audit trail enables debugging and compliance

### Negative

- More complex sync logic
- Requires manual intervention for conflicts
- Additional storage for sync metadata

### Neutral

- Migration needed for existing sync records
- Admin training required for conflict resolution

---

## References

- [Exact Online REST API - CRM/Accounts](https://start.exactonline.nl/docs/HlpRestAPIResourcesDetails.aspx?name=CRMAccounts)
- [Exact Online Sync API Documentation](https://support.exactonline.com/community/s/knowledge-base#All-All-DNO-Concept-api-apitypesc)
- Current implementation: `ExactOnlineSyncAdapter.kt`
