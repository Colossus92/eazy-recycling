# ADR-0012: Exact Online Company Synchronization Strategy

## Status

Proposed

## Context

We need a robust bidirectional synchronization strategy between Eazy Recycling and Exact Online for company data. The primary flow is:

1. **Initial sync**: Import existing companies from Exact Online
2. **Ongoing outbound**: Propagate creates/updates from Eazy Recycling to Exact Online
3. **Ongoing inbound**: Handle changes made directly in Exact Online

### Current State

#### Database Schema

**`companies` table:**

| Column | Type | Constraint |
|--------|------|------------|
| `id` | UUID | PRIMARY KEY |
| `chamber_of_commerce_id` | text | UNIQUE (nullable) |
| `vihb_id` | text | UNIQUE (nullable) |
| `processor_id` | text | UNIQUE (nullable) |
| `name` | text | NOT NULL |
| `street_name`, `postal_code`, `city` | text | NOT NULL |

**`companies_sync` table:**

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | PRIMARY KEY |
| `company_id` | UUID | FK to companies |
| `external_id` | text | Exact Online Code (nullable) |
| `sync_status` | text | OK, FAILED |
| `synced_from_source_at` | timestamp | Last sync time |
| `last_timestamp` | bigint | Exact Sync API timestamp |

#### Exact Online Constraints

From the CRM/Accounts API:

- **ID** (Edm.Guid): Primary key, auto-generated by Exact, immutable after creation
- **Code** (Edm.String): Auto-generated sequential number, unique per division, immutable
- **ChamberOfCommerce** (Edm.String): KVK number, not enforced as unique by Exact
- **Name** (Edm.String): Company name, not unique

#### Domain Model (`Company.kt`)

- `companyId: CompanyId` (UUID)
- `chamberOfCommerceId: String?`
- `vihbNumber: VihbNumber?`
- `processorId: ProcessorPartyId?`

### Current Implementation Issues

1. **UUID propagation to Exact**: Currently sending our UUID as the Exact `ID` field. This works for creates but:
   - Exact's `ID` is immutable after creation
   - If we need to merge companies later, we cannot change the Exact ID
   - Creates a tight coupling between systems

2. **Matching strategy gaps**: Current matching uses:
   - Chamber of Commerce ID (KVK)
   - External ID (Exact Code) via sync table
   - **Missing**: No handling for companies without KVK that exist in both systems

3. **Unique constraint violations**: When syncing from Exact, if a company has a KVK that already exists in our database (but wasn't linked), the sync fails.

---

## Decision

### 1. Identity Strategy: Decouple UUIDs

**Principle**: Each system owns its own primary key. Link via the sync table.

| System | Primary Key | Stored In |
|--------|-------------|-----------|
| Eazy Recycling | `companies.id` (UUID) | `companies` table |
| Exact Online | `ID` (GUID) | `companies_sync.exact_guid` |
| Exact Online | `Code` | `companies_sync.external_id` |

**Changes required:**
- Add `exact_guid` column to `companies_sync` table
- Stop sending our UUID as Exact's `ID` - let Exact auto-generate
- Store both Exact's `ID` (GUID) and `Code` in sync table

### 2. Matching Strategy: Multi-Key Resolution

When syncing from Exact, resolve matches in this priority order:

```text
1. exact_guid     → Direct link (highest confidence)
2. external_id    → Exact Code link
3. chamber_of_commerce_id → Business key match (KVK)
4. postal_code + building_number + building_number_addition → Exact address match (requires manual review)
5. No match       → Create new company
```

**For outbound sync (Eazy → Exact):**

```text
1. Check companies_sync for existing exact_guid
   → If exists: UPDATE in Exact
   → If not: CREATE in Exact, store returned ID/Code
```

### 3. Conflict Resolution Strategy

#### Scenario A: KVK Collision on Inbound Sync

**Problem**: Exact has company with KVK "12345678", our DB already has a different company with same KVK.

**Solution**:

1. Detect collision before insert
2. Mark as `CONFLICT` status in sync table
3. Log for manual resolution
4. Do NOT auto-merge or overwrite

```kotlin
enum class SyncStatus {
    OK,
    FAILED,
    CONFLICT,      // New: requires manual resolution
    PENDING_REVIEW // New: fuzzy match needs confirmation
}
```

#### Scenario B: Duplicate Creation Race Condition

**Problem**: User creates company in Eazy, another user creates same company in Exact before sync completes.

**Solution**:

1. On outbound sync, first check if KVK exists in Exact
2. If found, link to existing Exact account instead of creating
3. Store the found Exact ID/Code in sync table

#### Scenario C: Conflicting Updates

**Problem**: Company updated in both systems between syncs.

**Solution**:

- **Last-write-wins** with audit trail
- Store `updated_at` from both systems
- Log conflicts for review
- Consider field-level merge for non-conflicting fields

### 4. Unique Constraint Handling

#### Database-Level Protection

Current unique constraints on `companies`:

- `chamber_of_commerce_id`
- `vihb_id`
- `processor_id`

**Recommendation**: Keep these constraints but handle violations gracefully:

```kotlin
fun processExactAccount(account: ExactSyncAccount): SyncResult {
    try {
        // Attempt upsert
        upsertCompany(account)
    } catch (e: DataIntegrityViolationException) {
        // Unique constraint violation
        return SyncResult.Conflict(
            field = detectConflictingField(e),
            existingCompanyId = findExistingByConstraint(account),
            exactAccountId = account.ID
        )
    }
}
```

#### Pre-Sync Validation

Before creating/updating, check for potential conflicts:

```kotlin
fun validateBeforeSync(account: ExactSyncAccount): ValidationResult {
    val conflicts = mutableListOf<ConflictInfo>()
    
    account.ChamberOfCommerce?.let { kvk ->
        companies.findByChamberOfCommerceId(kvk)?.let { existing ->
            if (!isLinkedToExactAccount(existing, account.ID)) {
                conflicts.add(ConflictInfo("chamber_of_commerce_id", kvk, existing.companyId))
            }
        }
    }
    
    return if (conflicts.isEmpty()) ValidationResult.Valid 
           else ValidationResult.HasConflicts(conflicts)
}
```

### 5. Sync Table Schema Enhancement

```sql
ALTER TABLE companies_sync ADD COLUMN exact_guid UUID;
ALTER TABLE companies_sync ADD COLUMN conflict_details JSONB;
ALTER TABLE companies_sync ADD COLUMN requires_manual_review BOOLEAN DEFAULT FALSE;

-- Add unique constraint on exact_guid
CREATE UNIQUE INDEX companies_sync_exact_guid_key 
    ON companies_sync (exact_guid) WHERE exact_guid IS NOT NULL;

-- Add unique constraint on external_id (Exact Code)
CREATE UNIQUE INDEX companies_sync_external_id_key 
    ON companies_sync (external_id) WHERE external_id IS NOT NULL;
```

### 6. Sync Flow Diagrams

#### Outbound Sync (Eazy → Exact)

```text
┌─────────────────────────────────────────────────────────────────┐
│                    CREATE COMPANY IN EAZY                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Has KVK number? │
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │ YES                         │ NO
              ▼                             ▼
    ┌─────────────────────┐      ┌─────────────────────┐
    │ Search Exact by KVK │      │ Create in Exact     │
    └──────────┬──────────┘      │ (let Exact gen ID)  │
               │                 └──────────┬──────────┘
    ┌──────────┴──────────┐                 │
    │ FOUND               │ NOT FOUND       │
    ▼                     ▼                 ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────┐
│ Link existing │  │ Create new    │  │ Store Exact   │
│ Exact account │  │ in Exact      │  │ ID + Code     │
└───────────────┘  └───────────────┘  └───────────────┘
```

#### Inbound Sync (Exact → Eazy)

```text
┌─────────────────────────────────────────────────────────────────┐
│              FETCH CHANGED ACCOUNTS FROM EXACT                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ For each account│
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────────────────┐
              │ Match by exact_guid?     │
              └────────────┬─────────────┘
                           │
         ┌─────────────────┼─────────────────┐
         │ YES             │ NO              │
         ▼                 ▼                 │
   ┌───────────┐    ┌──────────────┐         │
   │ UPDATE    │    │ Match by     │         │
   │ existing  │    │ external_id? │         │
   └───────────┘    └──────┬───────┘         │
                           │                 │
              ┌────────────┼────────────┐    │
              │ YES        │ NO         │    │
              ▼            ▼            │    │
        ┌───────────┐ ┌──────────────┐  │    │
        │ UPDATE    │ │ Match by KVK?│  │    │
        │ existing  │ └──────┬───────┘  │    │
        └───────────┘        │          │    │
                    ┌────────┼────────┐ │    │
                    │ YES    │ NO     │ │    │
                    ▼        ▼        │ │    │
              ┌───────────┐ ┌─────────────────┐
              │ CONFLICT! │ │ CREATE new      │
              │ Mark for  │ │ company + link  │
              │ review    │ └─────────────────┘
              └───────────┘
```

---

## Risks and Mitigations

### Risk 1: Data Loss from Overwrites

**Risk**: Inbound sync overwrites local changes.

**Mitigation**:

- Compare `updated_at` timestamps
- Log all overwrites with before/after values
- Consider field-level merge instead of full overwrite

### Risk 2: Orphaned Records

**Risk**: Company deleted in one system but not the other.

**Mitigation**:

- Soft-delete only (both systems)
- Track `deleted_in_source` flag in sync table
- Never hard-delete during sync

### Risk 3: KVK Data Quality

**Risk**: KVK numbers may be incorrect, duplicated, or missing in Exact.

**Mitigation**:

- KVK is optional for matching
- Validate KVK format before using as match key
- Flag suspicious matches for review

### Risk 4: Sync Failures Causing Inconsistency

**Risk**: Partial sync leaves systems out of sync.

**Mitigation**:

- Process each account in its own transaction
- Track individual record status
- Implement retry mechanism for failed records
- Provide admin UI to view/resolve sync issues

### Risk 5: Race Conditions

**Risk**: Concurrent modifications during sync window.

**Mitigation**:

- Use optimistic locking with timestamps
- Exact's Sync API provides monotonic timestamps
- Store and compare `last_timestamp` per record

---

## 7. Deletion Policy

### Principle: Eazy Recycling Does NOT Delete in Exact Online

**Rationale**:

- Exact Online is the system of record for financial/accounting data
- Deleting accounts in Exact can corrupt financial history (invoices, transactions)
- Deletions should be intentional business decisions made by accounting staff
- Reduces risk of accidental data loss from sync bugs or user errors

### Handling Deletions from Exact Online

Exact Online provides a **Deleted API** (`/api/v1/{division}/sync/Deleted`) that tracks deleted entities for 2 months. This must be used alongside the Sync API to maintain data consistency.

#### Deleted API Details

```text
URI: /api/v1/{division}/sync/Deleted
Method: GET
Example: /api/v1/4002380/sync/Deleted?$filter=Timestamp gt 5&$select=Timestamp,DeletedBy,DeletedDate,Division,EntityKey,EntityType,ID
```

**Key Properties**:

| Property | Type | Description |
|----------|------|-------------|
| `Timestamp` | Edm.Int64 | Row version for incremental sync |
| `DeletedBy` | Edm.Guid | UserID who deleted the record |
| `DeletedDate` | Edm.DateTime | When the record was deleted |
| `EntityKey` | Edm.Guid | The ID of the deleted entity |
| `EntityType` | Edm.Int32 | Entity type (2 = Accounts) |
| `ID` | Edm.Guid | Primary key of the deletion record |

**Important Constraints**:

- Deletion log is retained for **2 months only**
- After 2 months, deletion records are automatically purged
- If a division is moved to another database, all timestamps reset (requires full re-sync)

### Deletion Sync Strategy

#### Inbound Deletion Flow (Exact → Eazy)

When a company is deleted in Exact Online:

```text
┌─────────────────────────────────────────────────────────────────┐
│           FETCH DELETED ACCOUNTS FROM EXACT                      │
│           (Timestamp > last_deleted_timestamp)                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ For each deleted│
                    │ account         │
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────────────────┐
              │ Find by EntityKey        │
              │ (exact_guid in sync)     │
              └────────────┬─────────────┘
                           │
         ┌─────────────────┼─────────────────┐
         │ FOUND           │ NOT FOUND       │
         ▼                 ▼                 │
   ┌───────────────┐ ┌───────────────┐       │
   │ Soft-delete   │ │ Log warning   │       │
   │ in Eazy       │ │ (already      │       │
   │ Mark sync as  │ │ deleted or    │       │
   │ DELETED       │ │ never synced) │       │
   └───────────────┘ └───────────────┘       │
```

**Implementation**:

1. Store separate `last_deleted_timestamp` cursor for the Deleted API
2. Query Deleted API with `EntityType eq 2` (Accounts)
3. For each deleted entity:
   - Look up `exact_guid` in `companies_sync`
   - If found: soft-delete the company, mark sync status as `DELETED`
   - If not found: log and continue (entity may have never been synced)

#### Outbound Deletion Flow (Eazy → Exact)

Eazy Recycling does **not** propagate deletions to Exact Online.

When a company is deleted in Eazy Recycling:

1. **Soft-delete only** in Eazy Recycling database
2. **Do NOT delete** in Exact Online
3. Mark sync status as `DELETED_LOCALLY`
4. Log the deletion for audit purposes

```kotlin
enum class SyncStatus {
    OK,
    FAILED,
    CONFLICT,
    PENDING_REVIEW,
    DELETED,           // Deleted in Exact, soft-deleted locally
    DELETED_LOCALLY    // Deleted locally, NOT propagated to Exact
}
```

### Schema Changes for Deletion Support

```sql
-- Add deletion tracking to sync cursor
ALTER TABLE companies_sync_cursor 
    ADD COLUMN cursor_type VARCHAR(20) DEFAULT 'sync';
-- cursor_type: 'sync' for regular sync, 'deleted' for deletion sync

-- Add deletion metadata to companies_sync
ALTER TABLE companies_sync 
    ADD COLUMN deleted_in_exact_at TIMESTAMP,
    ADD COLUMN deleted_in_exact_by UUID,
    ADD COLUMN deleted_locally_at TIMESTAMP;

-- Add deleted_by metadata to companies table (deleted_at already exists)
-- Note: deleted_by is metadata only, not used in queries to determine deletion status
ALTER TABLE companies 
    ADD COLUMN deleted_by UUID;
```

### Sync Cursor Management

The system must maintain **two separate cursors**:

| Cursor Type | Entity | Purpose |
|-------------|--------|---------|
| `sync` | `accounts` | Track last sync timestamp for new/updated records |
| `deleted` | `accounts` | Track last deletion timestamp |

**First-time sync**: Start both cursors at timestamp `1` (as per Exact API documentation).

**Cursor storage**:

```kotlin
data class SyncCursorDto(
    val id: UUID?,
    val entity: String,        // e.g., "accounts"
    val cursorType: String,    // "sync" or "deleted"
    val lastTimestamp: Long,
    val updatedAt: Instant
)
```

### 2-Month Retention Limitation

Since Exact Online only retains deletion records for 2 months:

1. **Sync frequency**: Run deletion sync **daily** via scheduled job to prevent falling behind
2. **Gap detection**: If last deletion sync was > 2 weeks ago, log a warning
3. **Recovery**: If gap exceeds 2 months, manual reconciliation may be required

### Risks and Mitigations for Deletion

#### Risk: Missing Deletions Due to 2-Month Limit

**Risk**: If sync doesn't run for > 2 months, deletions are lost.

**Mitigation**:

- Scheduled job runs deletion sync **daily**
- Alert if deletion sync hasn't run in > 2 weeks
- Manual reconciliation if gap exceeds 2 months

#### Risk: Orphaned Records in Eazy

**Risk**: Company deleted in Exact but still active in Eazy.

**Mitigation**:

- Regular deletion sync catches most cases
- Reconciliation job flags companies with `exact_guid` that no longer exist in Exact
- Admin UI shows "orphaned" companies for review

#### Risk: Accidental Local Deletion

**Risk**: User deletes company in Eazy that should remain in Exact.

**Mitigation**:

- Soft-delete only (can be restored)
- Audit log of all deletions
- No propagation to Exact (intentional design)

---

## Implementation Phases

### Phase 1: Schema Updates

1. Add `exact_guid` column to `companies_sync`
2. Add `conflict_details` JSONB column
3. Add `requires_manual_review` flag
4. Add unique indexes
5. **Add `cursor_type` to sync cursor table**
6. **Add deletion tracking columns**

### Phase 2: Decouple UUID

1. Stop sending our UUID as Exact's ID
2. Store Exact's returned GUID in `exact_guid`
3. Update matching logic to use `exact_guid` first

### Phase 3: Conflict Detection

1. Implement pre-sync validation
2. Add `CONFLICT` and `PENDING_REVIEW` statuses
3. Create admin endpoint to list conflicts

### Phase 4: Deletion Sync

1. **Implement Deleted API client**
2. **Add deletion cursor management**
3. **Add `DELETED` and `DELETED_LOCALLY` sync statuses**
4. **Create daily scheduled job for deletion sync**

### Phase 5: Conflict Resolution UI

1. Admin page showing sync conflicts
2. Manual merge/link functionality
3. Audit logging for resolutions
4. **Show deleted/orphaned companies**

---

## Consequences

### Positive

- Decoupled identity allows future flexibility (merging, splitting companies)
- Explicit conflict handling prevents silent data corruption
- Audit trail enables debugging and compliance
- **No accidental deletion of financial data in Exact**
- **Soft-delete preserves data recovery options**
- **Deletion sync keeps systems consistent**

### Negative

- More complex sync logic
- Requires manual intervention for conflicts
- Additional storage for sync metadata
- **2-month deletion retention requires regular sync cadence**
- **Cannot delete companies in Exact from Eazy (by design)**

### Neutral

- Migration needed for existing sync records
- Admin training required for conflict resolution
- Daily scheduled job required for deletion sync

---

## References

- [Exact Online REST API - CRM/Accounts](https://start.exactonline.nl/docs/HlpRestAPIResourcesDetails.aspx?name=CRMAccounts)
- [Exact Online Sync API Documentation](https://support.exactonline.com/community/s/knowledge-base#All-All-DNO-Concept-api-apitypesc)
- [Exact Online Deleted API](https://start.exactonline.nl/docs/HlpRestAPIResourcesDetails.aspx?name=SyncDeleted)
- Current implementation: `ExactOnlineSyncAdapter.kt`
